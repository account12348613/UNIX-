所有操作系统都为运行的程序提供服务：执行新程序、大开文件、读文件、分配存储区、获取当前时间等

1.登录
  登录名
  通过 cat /etc/passwd 命令查看登录名

  口令文件由7个以冒号分隔的字段组成：
  登录名：加密口令（密码）：数字用户ID：数字组ID：注释字段：起始目录 ：shell程序       例子
  abc  :x               :1000      :1000    :abc,,,  :/home/abc :/bin/bash
  
2.shell
  shell是一个命令行解释器，读取用户输入的命令，然后执行
  两种方式向shell输入：终端输入，文件（shell脚本）输入

3.文件系统
  根目录：目录的起点根（root），用字符 / 表示
  文件属性：文件类型、文件长度、文件所有者、文件许可权、文件最后修改时间等
  stat和fstat 函数返回一个所有文件属性的信息结构。
  
  文件名
  文件名中不能出现的字符只有两个： / 和 空操作符（null）
  / 用于分隔路径名中的各个文件名：/home/abc ，路径名中使用 / 来分隔各个文件名
  空操作符（null） 用于终止一个路径名
  当文件名中使用的特殊字符，必须使用shell的引号机制来引用文件名：cd "C:\Program Files\7-Zip" ，此处的文件名包含了空格，所以对路径加了引号“”
  创建一个新目录后，自动创建 . 和 .. 两个目录，分别是当前目录和父目录，在根目录中这两个目录相同。
  
  路径名
  0个或多个以斜线（/）分隔的文件名序列构成文件名，以斜线（/）开头的路径为绝对路径：cd /home/abc，否则为相对路径：cd ../snap或者 cd doc/memo/joe
  ls命令的代码实现：
******************************************************
#include <stdio.h>
#include <dirent.h>//DIR,struct dirent,

int main(int argc, char *argv[])
{
    DIR *dp;
    struct dirent *dirp;

    if(argc != 2)
        printf("input argument number error!\n");

    if((dp = opendir(argv[1])) == NULL)
        printf("open dir error!\n");

    while((dirp = readdir(dp)) != NULL)
    {
        printf("%s\n",dirp->d_name);
    }
    closedir(dp);
    return 0;
}
******************************************************
  此代码未对输出进行字母排序输出，ls命令则一般按字母顺序列出目录项
  
  使用opdendir、readdir、closedir来处理目录
  
  DIR *opendir(const char *name);
  返回指向DIR结构的指针，不用关心DIR结构中包含了什么。
  
  struct dirent *readdir(DIR *dirp);
  把DIR指针带入readdir，读取每个目录项，返回指向dirent结构体的指针，当目录中没有目录可读时返回NULL指针。
  dirent结构体中的目录名字可带入stat函数，来获取该文件的所有属性。
  
  
  工作目录
  每个进程都有一个工作目录，所有相对路径名都从工作目录开始解释，进程可以使用chdir更改其工作目录。
  
  
4.输入和输出
  
  文件描述符
  文件描述符是一个很小的非负整数，用来标识特定进程正在读写的文件。
  
  标准输入、标准输出、标准出错
  每当运行一个程序时，所有的shell都为其打开这三个文件描述符，一般都连向终端。
  重定向
  使用shell命令是可重定向到其他文件
  标准输入重定向 
  命令 < 文件             将指定文件作为命令的输入设备
  命令 << 分界符          示从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符其实就是自定义的字符串
  命令 < 文件 1 > 文件 2  将文件 1 作为命令的输入设备，该命令的执行结果输出到文件 2 中。
  标准输出重定向 
  命令 > 文件	      将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据。
  命令 2> 文件	    将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据。
  命令 >> 文件	    将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，新数据将写入到原有内容的后面。
  命令 2>> 文件	    将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将写入到原有内容的后面。
  命令 >> 文件 2>&1
  或者
  命令 &>> 文件	    将标准输出或者错误输出写入到指定文件，如果该文件中已包含数据，新数据将写入到原有内容的后面。注意，第一种格式中，最后的 2>&1 是一体的，可以认为是固定写法。
  
  不用缓存的I/O
  函数open、read、write、lseek、close提供了不带缓存的I/O，使用文件描述符工作
  代码：从标准输入读，写到标准输出
*****************************************************
#include <unistd.h>
#include <stdio.h>
#define BUFFSIZE 8192

int main()
{
    int n;
    char buf[BUFFSIZE];

    while((n = read(STDIN_FILENO,buf, BUFFSIZE))>0)
    {
        if((write(STDOUT_FILENO, buf, n)) != n)
        {
            printf("write error!\n");
        }
    }

    if(n < 0)
    {
        printf("read error!\n");
    }

    return 0;
}
*****************************************************
   STDIN_FILENO、STDOUT_FILENO在头文件<unistd.h>中，典型值是0、1。
   read、write也在此头文件中，read返回读取到的字节数，到达文件尾端时返回0，读错误返回-1。
  
  标准I/O（带缓存）
  标准I/O函数提供对不带缓存的I/O函数的带缓存的界面，使用标准I/O不需要担心如何选取最佳的缓存长度
  最熟悉的标准I/O函数是printf，头文件<stdio.h>包含了所有标准I/O函数的原型
  
  代码：从标准输入复制到标准输出
  
*****************************************************
#include <stdio.h>

int main()
{
    int c;
    while((c = getc(stdin)) != EOF)
    {
        if(putc(c, stdout)==EOF)
            printf("output err!\n");
    }

    if(ferror(stdin))
        printf("input err!\n");

    return 0;
}
*****************************************************
  函数getc一次读一个字符
  函数putc输出字符到标准输出
  读到最后一个字节时getc返回常数EOF（-1）
  标准输入、输出常数 stdin、stdout 定义在头文件<stdio.h>中
  
  
5.程序和进程

  程序
  存放在磁盘文件中的可执行文件
  
  进程和进程ID
  程序的执行实例为进程，或者用 任务 来表示正在被执行的程序
  每个进程都一定有一个唯一的数字标识符（进程ID），非负整数
  
  代码：打印进程ID
*****************************************************
#include <stdio.h>
#include <unistd.h>
int main()
{
    printf("process id = %d\n",getpid());
    return 0;
}
*****************************************************
  getpid()函数获取当前进程的进程ID
  
  
  进程控制
  主要函数：fork(),exec(),waitpid()
  代码：从标准输入读取命令并执行
*****************************************************
#include <stdio.h>
#include <unistd.h>//getpid(),pid_t
#include <string.h>//strlen()
#include <stdlib.h>//exit()
#include <sys/wait.h>//waitpid()
#define BUFFSIZE 8192
int main()
{
    char buf[BUFFSIZE];
    pid_t pid;
    int status;

    printf("%% ");
    while(fgets(buf, BUFFSIZE, stdin) != NULL)
    {
        buf[strlen(buf) - 1] = 0;

        if((pid = fork())<0)
            printf("fork err\n");

        else if(pid == 0)
        {
            execlp(buf, buf, (char *) 0);
            printf("can't execute: %s\n",buf);
            exit(127);
        }
        if((pid = waitpid(pid, &status, 0)) < 0)
        {
            printf("wait pid err\n");
        }
        printf("%% ");
    }
    return 0;
}
*****************************************************
  用标准I/O函数fgets()从标准输入一次读取一行
  当输入文件结束符（通常是ctrl+D）时，fgets()函数返回null指针，循环终止，则进程也终止。
  因为fgets()返回的每一行都以新行符终止，然后人为添加一个null字节，所以使用strlen()函数计算该字符串长度
  因为execlp()函数要求的是以null为结束的参数，而不是新行。所以此处用null代替新行符。
  fork()函数创建一个新进程，新进程为父进程的复制品。fork()函数返回两次，分别在父、子进程返回一次，在父进程返回子进程的进程ID，在子进程返回0。
  此处创建子进程来执行标准输入的命令。
  父进程通过waitpid()函数等待子进程终止，并获取子进程终止时的状态status。
  此函数使用了 % 作为命令提示符。
