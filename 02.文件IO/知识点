1.文件描述符
    对于内核，所有打开的文件都由 文件描述符 引用。文件描述符是一个非负整数
    当创建或者打卡一个文件时，内核向进程返回一个文件描述符；
    当读写一个文件时，将文件描述符作为参数传入相应函数。

    默认文件描述符：
        0，标准输入
        1，标准输出
        2，标标准出错
    头文件<unistd.h>中把幻数0、1、2 用STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO替换

2.open()函数
    open()函数 创建、打开一个文件。
    ########################################
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>

    int open(const char *pathname, int flags);
    int open(const char *pathname, int flags, mote_t mode);//创建时，才使用第三个参数mode
    ########################################
    返回：若成功返回文件描述符，若出错则返回-1

    pathname是要创建或打开的文件名
    flags可使用以下选项：
        O_RDONLY 只读打开，一般定义为 0
        O_WRONLY 只写打开，一般定义为 1
        O_RDWR   读写打开，一般定义为 2

    这三个常数只能指定一个，但是下列常数是和选择的：
        O_APPEND 写时追加到文件尾端
        O_CREAT  文件不存在则创建文件
        O_EXCL   检测文件是否存在，若同时指定了O_CREAT，则出错。
        O_TRUNC  将已存在、且以只读或者只写打开的文件的长度截短为0
        O_NOCTTY 如果pathname为终端设备，则不把这个设备分配给这个进程(如果指定STDOUT_FILENO，则这个进程的标准输出不再是STDOUT_FILENO)
        O_NONBLOCK 如果pathname是FIFO、块特殊文件、字符特殊文件，则把此文件的本次打开操作和后续IO操作设置为非阻塞模式
        O_SYNC   使得每次的write操作都等到物理的IO操作结束。

    open()函数返回的描述符一定是 未使用的、最小的 描述符数字。
    如果一个程序关闭了标准输出（描述符为1），再打开另外一个文件，则该文件会再描述符1上打开。

    文件名和路径名截短
        如果NAME_MAX为14个字符，我们创建了一个文件名长度为15个字符的时候，系统会返回ENAMETOOLONG的错误

3.create()函数
    creat()函数用于创建一个新的文件
    ########################################
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>

    int creat(const char *pathname, mode_t mode);
    ########################################
    返回：若成功则返回打开的文件描述符，失败则返回-1
    此函数等效于：
    open(pathname, O_WRONLY|O_CREAT|O_TRUNC, mode);

    open的不足之处：只能以只读打开创建的文件。如果要写创建的文件，操作是：creat(),close(),open()。

4.close()函数
    close()函数用于关闭一个已经打开的文件。
    ########################################
    #include <unistd.h>

    int close(int fd);
    ########################################
    关闭一个文件时，也释放该进程加在该文件上的所有记录锁。
    当一个进程终止时，所有打开的文件都会由内核自动关闭。

5.lseek()函数
    每个打开的文件都有一个与之关联的当前文件偏移量。是个非负整数，用来表示 从文件起始处 开始计算的字节数
    通常，读、写都是以当前文件的偏移量开始，读、写操作完成后，偏移量增加所操作的字节数。
    当打开一个文件时，默认的文件偏移量为0.
    lseek()函数返回一个文件的偏移量
    ########################################
    #include <sys/types.h>
    #include <unistd.h>

    off_t lseek(int fd, off_t offset, int whence);
    ########################################
    返回值：若成功返回文件当前的偏移量，出错返回-1
    参数offset的解释与参数whence的值有关：
    whence是 SEEK_SET :设置该文件的偏移量为offset
    whence是 SEEK_CUR :设置该文件的偏移量为offset+文件已有的偏移量。offset可正可负。
    whence是 SEEK_END :设置该文件的偏移量为文件长度+offset。offset可正可负。

    lseek(fd, 0, SEEK_CUR);
    代码用于确定文件是否可以设置偏移量，当文件描述符为管道、FIFO时，lseek返回-1，并将errno设置为EPIPE。
    代码：测试标准输入能否设置偏移量。文件见1check_offset.c
***********************************************************
#include <stdio.h>
#include <unistd.h>//lseek(),STDIN_FILENO
int main()
{
    if(lseek(STDIN_FILENO, 0, SEEK_CUR) == -1)
        printf("can't seek\n");
    else
        printf("seek ok\n");
    return 0;
}
***********************************************************
    通常文件当前的偏移量应该是个非负整数，但是某些设备允许负的偏移量。
    对于普通文件，其偏移量必须是非负值。如果偏移量可能为负值，那么在lseek函数返回时，应该判断是否为-1，而不是小于0.
    lseek只把当前文件的偏移量记录在内核内，并不引起任何的IO操作。该偏移量用于下一次的读、写操作。
    文件的偏移量可以大于文件的当前长度。中间的空位使用0填充

6.read()函数
7.write()函数
8.I/O效率
9.文件共享
10.原子操作
11.dup()和dup2()函数
12.fcntl()函数
13.ioctl()函数
14./dev/fd
