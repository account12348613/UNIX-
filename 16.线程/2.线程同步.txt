互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景
https://blog.csdn.net/qq_34827674/article/details/108608566?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164868779716781685333883%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164868779716781685333883&biz_id=0&spm=1018.2226.3001.4187

c语言中static关键字用法详解
https://blog.csdn.net/guotianqing/article/details/79828100

线程同步的两个工具：互斥量、条件变量

互斥量：防止线程A试图访问一个共享变量时，线程B正在对其修改。
条件变量：允许线程间相互通知共享变量的状态发生了变化。

临界区：访问一共享资源的代码片段，并且该代码的执行为原子操作。

互斥量的两种状态：锁定和未锁定
    任何时候只有一个线程可以锁定该互斥量
    对已经锁定的互斥量再次锁定可能阻塞线程或者报错失败。
    只有所有者才能对该互斥量解锁

    一般情况下，不同的共享资源会使用不同的互斥量，每个线程访问共享资源时应遵守如下规则：
        1.针对共享资源锁定互斥量
        2.操作共享资源
        3.互斥量解锁

静态分配的互斥量
    类型：pthread_mutex_t
    使用前必须进行初始化
    可使用 pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER 进行赋值。

    初始化后，互斥量处于未锁定的状态，可使用pthread_mutex_lock()对互斥量进行锁定。

    #include <pthread.h>

    int pthread_mutex_lock(pthread_mutex_t *mutex);
    int pthread_mutex_unlock(pthread_mutex_t *mutex);
    返回0代表成功，出错时返回一个正数

    如果互斥量处于未锁定状态，phtread_mutex_lock()将锁定互斥量后立即返回；
    如果互斥量被其他线程锁定，phtread_mutex_lock()将一直阻塞，直到该互斥量被解锁，然后锁定该互斥量并返回。

    如果一个线程锁定了一个互斥量后，再次锁定该互斥量，将会导致两个结果:
        线程陷入死锁：因为线程试图锁定自己持有的互斥量而遭到阻塞
        调用失败，返回EDEADLK错误

    函数pthread_mutex_unlock()将解锁本线程锁定的互斥量，以下两种操作均是错误的：
        对未锁定的互斥量进行解锁
        解锁其他线程锁定的互斥量